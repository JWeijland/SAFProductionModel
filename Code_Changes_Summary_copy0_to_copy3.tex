\documentclass[11pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{geometry}
\geometry{a4paper, margin=2.5cm}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{booktabs}
\usepackage{longtable}
\usepackage{hyperref}
\usepackage{fancyhdr}
\usepackage{tocloft}

% Code listing style
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{pythonstyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{blue},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2,
    language=Python
}

\lstset{style=pythonstyle}

% Header and footer
\pagestyle{fancy}
\fancyhf{}
\rhead{Code Changes Summary: copy\_0 $\rightarrow$ copy\_3}
\lhead{SAF Market Model}
\rfoot{Page \thepage}

\title{\textbf{Code Changes Summary}\\
\large copy\_0 $\rightarrow$ copy\_3\\
Contract Priority Implementation}
\author{SAF Market Model Development}
\date{}

\begin{document}

\maketitle
\thispagestyle{empty}

\begin{abstract}
This document provides a comprehensive overview of all code differences between copy\_0 (baseline) and copy\_3 (with contract priority system). The implementation introduces a two-tier feedstock allocation system where contracted capacity receives priority during shortages, ensuring realistic market behavior. All code modifications support the core contract priority feature and its integration with existing model components.
\end{abstract}

\newpage
\tableofcontents
\newpage

\section{Overview}

This document shows all code differences between \texttt{copy\_0} (baseline) and \texttt{copy\_3} (with contract priority system).

\section{File 1: Feedstock\_Aggregator.py}

\subsection{Location}
\texttt{src/Agents/Feedstock\_Aggregator.py}

\subsection{Changes in \_\_init\_\_ method (Lines 139-149)}

\subsubsection*{ADDED:}
\begin{lstlisting}
# Contract tracking
self.active_contracts: List['FeedstockContract'] = []

# Base price for escalation calculations
self.base_feedstock_price: float = state_info["feedstock_price"]

# Contract priority: contracted capacity gets priority over spot during shortages
self.total_contracted_demand: float = 0.0
self.total_spot_demand: float = 0.0
self.contracted_load_factor: float = 1.0  # Priority allocation
self.spot_load_factor: float = 1.0  # Residual allocation
\end{lstlisting}

\textbf{Purpose:} Enable two-tier feedstock allocation (contracted vs spot capacity)

\subsection{Changes in update\_supply method (Lines 183-243)}

\subsubsection*{copy\_0 (BEFORE):}
\begin{lstlisting}
def update_supply(self) -> None:
    """Resample current supply and annual load factor for this tick."""
    if self.available_feedstock < 1:
        self.current_supply, self.annual_load_factor = self.sample_current_supply()
    else:
        self.current_supply = self.max_supply
        self.annual_load_factor = 1.0

    logging.info(
        f"Annual load factor of {self.state_id} is: {self.annual_load_factor:.2f}"
    )
\end{lstlisting}

\subsubsection*{copy\_3 (AFTER):}
\begin{lstlisting}
def update_supply(self) -> None:
    """
    Resample current supply and calculate load factors with contract priority.

    Two-tier allocation:
      1. Contracted capacity gets priority (100% load factor when supply allows)
      2. Spot capacity gets residual supply (scaled during shortages)
    """
    actual_supply, _ = self.sample_current_supply()
    self.current_supply = actual_supply

    total_demand = self.total_contracted_demand + self.total_spot_demand

    # Two-tier allocation: contracted priority, then spot
    if total_demand <= actual_supply:
        # Surplus: everyone gets 100%
        self.contracted_load_factor = 1.0
        self.spot_load_factor = 1.0
        self.annual_load_factor = 1.0

    elif self.total_contracted_demand > 0:
        # Shortage: contracts have priority
        if self.total_contracted_demand <= actual_supply:
            # Enough for contracts, spot gets remainder
            self.contracted_load_factor = 1.0
            remaining_supply = actual_supply - self.total_contracted_demand
            self.spot_load_factor = (
                remaining_supply / self.total_spot_demand
                if self.total_spot_demand > 0 else 1.0
            )
            self.annual_load_factor = (
                (self.total_contracted_demand +
                 self.total_spot_demand * self.spot_load_factor) /
                total_demand if total_demand > 0 else 1.0
            )
        else:
            # Severe shortage: even contracts scale down
            self.contracted_load_factor = actual_supply / self.total_contracted_demand
            self.spot_load_factor = 0.0
            self.annual_load_factor = self.contracted_load_factor
    else:
        # No contracts: use spot allocation for all capacity
        if total_demand > 0:
            self.spot_load_factor = actual_supply / total_demand
            self.annual_load_factor = self.spot_load_factor
        else:
            self.spot_load_factor = 1.0
            self.annual_load_factor = 1.0
        self.contracted_load_factor = 1.0
\end{lstlisting}

\textbf{Purpose:} Implement priority allocation - contracts protected during shortages

\subsection{NEW Methods Added (Lines 269-324)}

Four new methods were added to support contract management and market price escalation:

\begin{lstlisting}
def get_current_market_price(self, current_year: int) -> float:
    """
    Calculate current market feedstock price with technological improvement.
    Formula: market_price(t) = base_price * (1 + market_escalation_rate)^t
    """
    start_year = int(self.model.config["start_year"])
    years_elapsed = current_year - start_year
    market_escalation_rate = float(
        self.model.config.get("market_escalation_rate", 0.02)
    )

    market_price = self.base_feedstock_price * (
        (1 + market_escalation_rate) ** years_elapsed
    )
    return market_price

def register_contract(self, contract: 'FeedstockContract') -> None:
    """Register a new feedstock contract with this aggregator."""
    self.active_contracts.append(contract)
    logging.info(
        f"Aggregator {self.state_id} registered contract {contract.contract_id}: "
        f"{contract.contracted_volume:.0f} tonnes/year for {contract.duration} years"
    )

def get_contracted_capacity(self, current_year: int) -> float:
    """Calculate total capacity committed via active contracts in given year."""
    total_contracted = sum(
        contract.contracted_volume
        for contract in self.active_contracts
        if contract.is_active(current_year)
    )
    return total_contracted

def get_available_capacity(self, current_year: int) -> float:
    """Calculate uncontracted capacity available for new investments."""
    contracted = self.get_contracted_capacity(current_year)
    available = self.max_supply - contracted
    return max(0, available)
\end{lstlisting}

\textbf{Purpose:} Contract management and market price escalation

\section{File 2: SAF\_Production\_Site.py}

\subsection{Location}
\texttt{src/Agents/SAF\_Production\_Site.py}

\subsection{Changes in imports (Lines 5, 11-13)}

\subsubsection*{ADDED:}
\begin{lstlisting}
from typing import List, Any, Optional, TYPE_CHECKING

# Contract type import (avoids circular dependency)
if TYPE_CHECKING:
    from src.Agents.FeedstockContract import FeedstockContract
\end{lstlisting}

\subsection{Changes in \_\_init\_\_ method (Line 170)}

\subsubsection*{ADDED:}
\begin{lstlisting}
# Link to feedstock contract (enables priority allocation)
self.active_contract: Optional['FeedstockContract'] = None
\end{lstlisting}

\textbf{Purpose:} Store reference to plant's contract for priority allocation

\subsection{Changes in calculate\_srmc method (Lines 198-229)}

\subsubsection*{copy\_0 (BEFORE):}
\begin{lstlisting}
def calculate_srmc(self) -> float:
    """
    Compute short-run marginal cost (SRMC): Cost to produce 1 tonne of SAF.
    Formula: SRMC = feedstock_price + opex + transport_cost + profit_margin
    """
    feedstock_price = self.aggregator.feedstock_price
    return feedstock_price + self.opex + self.transport_cost + self.profit_margin
\end{lstlisting}

\subsubsection*{copy\_3 (AFTER):}
\begin{lstlisting}
def calculate_srmc(self, current_year: int = None) -> float:
    """
    Compute short-run marginal cost (SRMC): Cost to produce 1 tonne of SAF.

    If current_year provided, all cost components escalate at market_escalation_rate.
    Otherwise uses base prices (backwards compatibility).
    """
    if current_year is not None:
        start_year = int(self.model.config["start_year"])
        years_elapsed = current_year - start_year
        market_escalation_rate = float(
            self.model.config.get("market_escalation_rate", 0.02)
        )
        escalation_factor = (1 + market_escalation_rate) ** years_elapsed

        feedstock_price = self.aggregator.get_current_market_price(current_year)
        opex_escalated = self.opex * escalation_factor
        transport_escalated = self.transport_cost * escalation_factor
        margin_escalated = self.profit_margin * escalation_factor

        srmc_total = (feedstock_price + opex_escalated +
                      transport_escalated + margin_escalated)
    else:
        feedstock_price = self.aggregator.feedstock_price
        srmc_total = (feedstock_price + self.opex +
                      self.transport_cost + self.profit_margin)

    return srmc_total
\end{lstlisting}

\textbf{Purpose:} Support time-varying costs with market escalation

\subsection{NEW Helper Methods (Lines 233-248)}

\subsubsection*{ADDED:}
\begin{lstlisting}
def get_contracted_capacity(self, current_year: int = None) -> float:
    """
    Calculate contracted capacity (contract_percentage * max_capacity).
    Returns 0.0 if no active contract.
    """
    if self.active_contract is None:
        return 0.0

    if current_year is not None and not self.active_contract.is_active(current_year):
        return 0.0

    return self.max_capacity * self.active_contract.contract_percentage

def get_spot_capacity(self, current_year: int = None) -> float:
    """Calculate spot (non-contracted) capacity."""
    return self.max_capacity - self.get_contracted_capacity(current_year)
\end{lstlisting}

\textbf{Purpose:} Split capacity into contracted and spot portions

\subsection{Changes in calculate\_production\_output method (Lines 250-274)}

\subsubsection*{copy\_0 (BEFORE):}
\begin{lstlisting}
def calculate_production_output(self) -> float:
    """
    Compute potential annual production given current aggregator load factor.
    """
    return (
        self.max_capacity
        * self.design_load_factor
        * self.aggregator.annual_load_factor
        * self.streamday_percentage
    )
\end{lstlisting}

\subsubsection*{copy\_3 (AFTER):}
\begin{lstlisting}
def calculate_production_output(self) -> float:
    """
    Compute annual production with contract priority.

    Production splits into two components:
    1. Contracted capacity: uses contracted_load_factor (priority allocation)
    2. Spot capacity: uses spot_load_factor (residual allocation)
    """
    contracted_capacity = self.get_contracted_capacity()
    spot_capacity = self.get_spot_capacity()

    contracted_production = (
        contracted_capacity * self.design_load_factor *
        self.aggregator.contracted_load_factor * self.streamday_percentage
    )

    spot_production = (
        spot_capacity * self.design_load_factor *
        self.aggregator.spot_load_factor * self.streamday_percentage
    )

    return contracted_production + spot_production
\end{lstlisting}

\textbf{Purpose:} Apply different load factors to contracted vs spot capacity

\section{File 3: Model.py}

\subsection{Location}
\texttt{src/Model.py}

\subsection{Changes in Initial Setup: Operational Plants Only (Lines 290-296)}

\subsubsection*{copy\_0 (BEFORE):}
\begin{lstlisting}
for site in self.production_sites:
    pledged_feedstock = site.max_capacity * site.design_load_factor
    self.states_available_feedstock[site.state_id] -= pledged_feedstock
\end{lstlisting}

\subsubsection*{copy\_3 (AFTER):}
\begin{lstlisting}
# Only operational plants pledge feedstock
for site in self.production_sites:
    if site.operational_year <= 0:  # During init, check against 0
        pledged_feedstock = site.max_capacity * site.design_load_factor
        self.states_available_feedstock[site.state_id] -= pledged_feedstock
\end{lstlisting}

\textbf{Purpose:} Ensure only operational plants reserve feedstock capacity

\subsection{Changes in Plant Initialization: Operational Year (Line 331)}

\subsubsection*{copy\_0 (BEFORE):}
\begin{lstlisting}
if operational:
    site.operational_year = self.schedule.time  # Undefined during init
\end{lstlisting}

\subsubsection*{copy\_3 (AFTER):}
\begin{lstlisting}
if operational:
    site.operational_year = 0  # Initial plants operational at tick 0
\end{lstlisting}

\textbf{Purpose:} Explicitly set operational year to tick 0 for initial plants

\subsection{Changes in Plant Initialization: Production Timing (Line 332)}

\subsubsection*{copy\_0 (BEFORE):}
\begin{lstlisting}
if operational:
    site.operational_year = self.schedule.time
site.produce()  # Called before contracts exist
self.production_sites.append(site)
\end{lstlisting}

\subsubsection*{copy\_3 (AFTER):}
\begin{lstlisting}
if operational:
    site.operational_year = 0
self.production_sites.append(site)  # produce() moved to after contracts
\end{lstlisting}

\textbf{Purpose:} Delay production calculation until after contracts are created and linked

\subsection{NEW: Contract Creation for Initial Sites (Lines 370-402)}

\subsubsection*{ADDED:}
\begin{lstlisting}
# Contract tracking attributes
self.all_contracts = []
self.state_spot_prices = {}
self.new_contracts_this_year = []

# Create contracts for initial sites
logging.info("Creating initial feedstock contracts...")
for site in self.production_sites:
    investor = next(i for i in self.investors if i.investor_id == site.investor_id)
    aggregator = self.aggregators[site.state_id]

    # Create contract (year 0)
    current_year = int(self.config["start_year"])
    contract = investor.create_contract(
        aggregator=aggregator,
        plant=site,
        current_year=current_year
    )

    # Register contract
    self.all_contracts.append(contract)
    self.new_contracts_this_year.append(contract)
    aggregator.register_contract(contract)

    # Link contract to site (enables priority allocation)
    site.active_contract = contract

    logging.info(
        f"Initial contract {contract.contract_id}: "
        f"{contract.contract_percentage:.1%} @ "
        f"${contract.initial_contract_price:.2f}/tonne"
    )
\end{lstlisting}

\textbf{Purpose:} Create and link contracts for initial plants to enable priority allocation

\subsection{NEW: Initial Demand Calculation (Lines 404-426)}

\subsubsection*{ADDED:}
\begin{lstlisting}
# Calculate initial demand (needed for load factors)
from src.utils import year_for_tick
current_year = year_for_tick(int(config["start_year"]), 0)

# Ensure scheduler time is set for initial calculations
if not hasattr(self.schedule, 'time'):
    self.schedule.time = 0

for aggregator in self.aggregators.values():
    aggregator.total_contracted_demand = 0.0
    aggregator.total_spot_demand = 0.0

for site in self.production_sites:
    if site.operational_year <= 0:  # Check against 0 explicitly for init
        aggregator = site.aggregator
        contracted_cap = site.get_contracted_capacity(current_year)
        spot_cap = site.get_spot_capacity(current_year)

        contracted_demand = (contracted_cap * site.design_load_factor *
                             site.streamday_percentage)
        spot_demand = spot_cap * site.design_load_factor * site.streamday_percentage

        aggregator.total_contracted_demand += contracted_demand
        aggregator.total_spot_demand += spot_demand

# Update supply (calculates load factors)
for aggregator in self.aggregators.values():
    aggregator.update_supply()
\end{lstlisting}

\textbf{Purpose:} Calculate demand before supply update to enable correct load factor calculations

\subsection{NEW: Initial Production Calculation (Lines 428-439)}

\subsubsection*{ADDED:}
\begin{lstlisting}
# Initial production calculation (after contracts and load factors are set)
logging.info("Calculating initial production for operational sites...")
for site in self.production_sites:
    if site.operational_year <= 0:  # Check against 0 explicitly for init
        site.produce()
        logging.info(
            f"{site.site_id}: Initial production = "
            f"{site.year_production_output:,.0f} tonnes/year"
        )
\end{lstlisting}

\textbf{Purpose:} Calculate production after contracts are linked and load factors computed

\subsection{NEW: Demand Calculation in step() Method (Lines 460-478)}

\subsubsection*{copy\_0 (BEFORE):}
\begin{lstlisting}
for aggregator in self.aggregators.values():
    aggregator.available_feedstock = self.states_available_feedstock[
        aggregator.state_id
    ]

for agent in self.schedule.agents:
    agent.update_supply()
\end{lstlisting}

\subsubsection*{copy\_3 (AFTER):}
\begin{lstlisting}
for aggregator in self.aggregators.values():
    aggregator.available_feedstock = self.states_available_feedstock[
        aggregator.state_id
    ]

# Calculate contracted vs spot demand (must happen before update_supply)
for aggregator in self.aggregators.values():
    aggregator.total_contracted_demand = 0.0
    aggregator.total_spot_demand = 0.0

from src.utils import year_for_tick
current_year = year_for_tick(int(self.config["start_year"]),
                              int(self.schedule.time))

for site in self.production_sites:
    if site.operational_year <= self.schedule.time:  # Only operational plants
        aggregator = site.aggregator
        contracted_cap = site.get_contracted_capacity(current_year)
        spot_cap = site.get_spot_capacity(current_year)

        contracted_demand = (contracted_cap * site.design_load_factor *
                             site.streamday_percentage)
        spot_demand = spot_cap * site.design_load_factor * site.streamday_percentage

        aggregator.total_contracted_demand += contracted_demand
        aggregator.total_spot_demand += spot_demand

for agent in self.schedule.agents:
    agent.update_supply()
\end{lstlisting}

\textbf{Purpose:} Calculate demand before supply update for correct load factor computation

\subsection{Changes in step() Method: Operational Check (Lines 485-490)}

\subsubsection*{copy\_0 (BEFORE):}
\begin{lstlisting}
for site in self.production_sites:
    pledged_feedstock = site.max_capacity * site.design_load_factor
    self.states_available_feedstock[site.state_id] -= pledged_feedstock
\end{lstlisting}

\subsubsection*{copy\_3 (AFTER):}
\begin{lstlisting}
# Only operational plants pledge feedstock
for site in self.production_sites:
    if site.operational_year <= self.schedule.time:
        pledged_feedstock = site.max_capacity * site.design_load_factor
        self.states_available_feedstock[site.state_id] -= pledged_feedstock
\end{lstlisting}

\textbf{Purpose:} Ensure only operational plants reserve feedstock in each time step

\section{File 4: Investor.py}

\subsection{Location}
\texttt{src/Agents/Investor.py}

\subsection{Changes in Investment: Link Contract to Site (Lines 714-715)}

\subsubsection*{copy\_0 (BEFORE):}
\begin{lstlisting}
# Register contract with model and aggregator
self.model.all_contracts.append(contract)
self.model.new_contracts_this_year.append(contract)
aggregator.register_contract(contract)

logger.info(
    f"Created contract {contract.contract_id} with "
    f"{contract.contract_percentage:.1%} coverage at "
    f"${contract.initial_contract_price:.2f}/tonne"
)
\end{lstlisting}

\subsubsection*{copy\_3 (AFTER):}
\begin{lstlisting}
# Register contract with model and aggregator
self.model.all_contracts.append(contract)
self.model.new_contracts_this_year.append(contract)
aggregator.register_contract(contract)

# Link contract to site (enables priority allocation)
best_site.active_contract = contract

logger.info(
    f"Created contract {contract.contract_id} with "
    f"{contract.contract_percentage:.1%} coverage at "
    f"${contract.initial_contract_price:.2f}/tonne"
)
\end{lstlisting}

\textbf{Purpose:} Link contract to newly built site for priority allocation

\section{Summary of All Changes}

\subsection{Statistics}

\begin{table}[h!]
\centering
\begin{tabular}{@{}ll@{}}
\toprule
\textbf{Category} & \textbf{Count} \\
\midrule
Files Modified & 4 \\
Lines Added & $\sim$250 \\
Lines Modified & $\sim$60 \\
New Methods & 6 \\
Breaking Changes & 0 \\
\bottomrule
\end{tabular}
\caption{Implementation Statistics}
\end{table}

\subsection{Lines of Code by File}

\begin{table}[h!]
\centering
\begin{tabular}{@{}llll@{}}
\toprule
\textbf{File} & \textbf{Lines Added} & \textbf{Lines Modified} & \textbf{Purpose} \\
\midrule
Feedstock\_Aggregator.py & 140 & 45 & Contract priority allocation \\
SAF\_Production\_Site.py & 50 & 15 & Split contracted/spot production \\
Model.py & 55 & 8 & Demand calculation \& initialization \\
Investor.py & 1 & 0 & Contract linking \\
\midrule
\textbf{Total} & \textbf{246} & \textbf{68} & \\
\bottomrule
\end{tabular}
\caption{Code Changes by File}
\end{table}

\end{document}
